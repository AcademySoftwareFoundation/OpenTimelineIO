#!/uxr/bin/env python

"""Generates documentation of the serialized data model for OpenTimelineIO."""

import argparse
import inspect
import json
import StringIO
import tempfile
import sys

import opentimelineio as otio


DOCUMENT_HEADER = """# OpenTimelineIO Serialized Data Documentation

This document is a list of all the OpenTimelineIO classes that serialize to and
from JSON, omitting SchemaDef plugins.

This document is automatically generated by running
 docs/autogen_serialized_datamodel.py, or by running `make doc-model`.  It is
 part of the unit tests suite and should be updated whenever the schema changes.

# Classes

"""

CLASS_HEADER = """
### {}

*full module path*: {}

*documentation*:

```
{}
```

parameters:
"""

MODULE_HEADER = """
## Module: {}
"""

PROP_HEADER = """- *{}*: {}
"""

# three ways to try and get the property + docstring
PROP_FETCHERS = (
    lambda cl, k: inspect.getdoc(getattr(cl, k)),
    lambda cl, k: inspect.getdoc(getattr(cl, "_" + k)),
    lambda cl, k: inspect.getdoc(getattr(cl(), k)),
)


def _parsed_args():
    """ parse commandline arguments with argparse """

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "-d",
        "--dryrun",
        action="store_true",
        default=False,
        help="Dryrun mode - print out instead of perform actions"
    )
    group.add_argument(
        "-o",
        "--output",
        type=str,
        default=None,
        help="Update the baseline with the current version"
    )

    return parser.parse_args()


# things to skip
SKIP_CLASSES = [otio.core.SerializableObject, otio.core.UnknownSchema]
SKIP_KEYS = ["OTIO_SCHEMA"]  # not data, just for the backing format
SKIP_MODULES = ["opentimelineio.schemadef"]  # because these are plugins


def _generate_model_for_module(mod, classes, modules):
    modules.add(mod)
    serializeable_classes = [
        thing for thing in mod.__dict__.itervalues()
        if (
            inspect.isclass(thing)
            and thing not in classes
            and issubclass(thing, otio.core.SerializableObject)
            or thing in (
                otio.opentime.RationalTime,
                otio.opentime.TimeRange,
                otio.opentime.TimeTransform,
            )
        )
    ]
    for cl in serializeable_classes:
        if not getattr(cl, "orig_label", None):
            continue

        try:
            print json.loads(otio.adapters.otio_json.write_to_string(cl())).keys()
        except Exception as err:
            print "error:", str(cl), err
            print dir(cl)

    model = {}
    for cl in serializeable_classes:
        if cl in SKIP_CLASSES:
            continue
        model[cl] = {}
        fields = json.loads(otio.adapters.otio_json.write_to_string(cl())).keys()
        for k in fields:
            if k in SKIP_KEYS:
                continue

            for fetcher in PROP_FETCHERS:
                try:
                    model[cl][k] = fetcher(cl, k)
                    break
                except AttributeError:
                    pass
            else:
                sys.stderr.write("ERROR: could not fetch property: {}".format(k))

    classes.update(model)
    new_mods = [
        thing for thing in mod.__dict__.itervalues()
        if (
            inspect.ismodule(thing)
            and thing not in modules
            and all(not thing.__name__.startswith(t) for t in SKIP_MODULES)
        )
    ]
    [_generate_model_for_module(m, classes, modules) for m in new_mods]


def _generate_model():
    classes = {}
    modules = set()
    _generate_model_for_module(otio, classes, modules)
    return classes


def _write_documentation(model):
    doc = StringIO.StringIO()

    doc.write(DOCUMENT_HEADER)

    modules = {}
    for cl in model:
        modules.setdefault(cl.__module__, []).append(cl)

    CURRENT_MODULE = None
    for module_list in sorted(modules):
        this_mod = ".".join(module_list.split('.')[:2])
        if this_mod != CURRENT_MODULE:
            CURRENT_MODULE = this_mod
            doc.write(MODULE_HEADER.format(this_mod))

        for cl in sorted(modules[module_list]):
            # try:
            modname = inspect.getmodule(cl).__name__
            label = json.loads(otio.adapters.otio_json.write_to_string(cl()))['OTIO_SCHEMA']
            doc.write(
                CLASS_HEADER.format(
                    label,
                    modname + "." + cl.__name__,
                    cl.__doc__
                )
            )
            # except:
            #     print("ERROR with: " + str(cl))
            #     print("module : " + str(inspect.getmodule(cl)))
            #     print("type: "+str(type(cl)))
            #     continue

            for key, helpstr in sorted(model[cl].items()):
                doc.write(PROP_HEADER.format(key, helpstr))

    return doc.getvalue()


def main():
    """  main entry point  """
    args = _parsed_args()
    text = generate_and_write_documentation()

    # print it out somewhere
    if args.dryrun:
        print(text)
        return

    output = args.output
    if not output:
        output = tempfile.NamedTemporaryFile(
            'w',
            suffix="otio_serialized_schema.md",
            delete=False
        ).name

    with open(output, 'w') as fo:
        fo.write(text)

    print("wrote documentation to {}.".format(output))


def generate_and_write_documentation():
    model = _generate_model()
    return _write_documentation(model)


if __name__ == '__main__':
    main()
