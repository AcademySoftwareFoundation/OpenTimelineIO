#!/usr/bin/env python
#
# copyright 2019 pixar animation studios
#
# licensed under the apache license, version 2.0 (the "apache license")
# with the following modification; you may not use this file except in
# compliance with the apache license and the following modification to it:
# section 6. trademarks. is deleted and replaced with:
#
# 6. trademarks. this license does not grant permission to use the trade
#    names, trademarks, service marks, or product names of the licensor
#    and its affiliates, except as required to comply with section 4(c) of
#    the license and to reproduce the content of the notice file.
#
# you may obtain a copy of the apache license at
#
#     http://www.apache.org/licenses/license-2.0
#
# unless required by applicable law or agreed to in writing, software
# distributed under the apache license with the above modification is
# distributed on an "as is" basis, without warranties or conditions of any
# kind, either express or implied. see the apache license for the specific
# language governing permissions and limitations under the apache license.
#

"""Generates documentation of all the built in plugins for OpenTimelineIO"""

# @TODO: separate core and contrib adapters into different groups
# @TODO: unit test
# @TODO: makefile support for updating the baseline

import argparse
import tempfile

try:
    # python2
    import StringIO as io
except ImportError:
    # python3
    import io

import opentimelineio as otio


DOCUMENT_HEADER = """# Plugin Documentation

This documents all the plugins that ship with in the open source OpenTimelineIO
distribution.

This document is automatically generated by running
autogen_plugin_documentation, or by running `make plugin-model`.  It is part of
the unit tests suite and should be updated whenever the schema changes.  If it
needs to be updated, run: `make doc-model-update` and this file should be
regenerated.

## Contrib vs Core

Plugins in Contrib are supported by the community and provided as-is.

# Manifests

The manifests describe plugins that ship with OpenTimelineIO.  They are read in
order, from top to bottom.

{manifests}

# Adapter Plugins

Adapter plugins convert to and from OpenTimelineIO.

Documentation on adapters: *TODO*

{adapters}

# Media Linkers

Media Linkers run after the adapter has read in the file and convert the media
references into valid references where appropriate.

{media_linkers}

# SchemaDefs

SchemaDef plugins define new external schema.

{schemadefs}

# HookScripts

HookScripts are extra plugins that run on _hooks_.

{hook_scripts}

# Hooks

Hooks are the points at which hookscripts will run.

{hooks}

"""

PLUGIN_TEMPLATE = """
## {name}

```
{doc}
```

source: {path}
core or contrib: {core_or_contrib}

other: {other}

"""


def _parsed_args():
    """ parse commandline arguments with argparse """

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "-d",
        "--dryrun",
        action="store_true",
        default=False,
        help="Dryrun mode - print out instead of perform actions"
    )
    group.add_argument(
        "-o",
        "--output",
        type=str,
        default=None,
        help="Update the baseline with the current version"
    )

    return parser.parse_args()


def _format_plugin(plugin_map):
    return PLUGIN_TEMPLATE.format(
        name=plugin_map['name'],
        doc=plugin_map['doc'],
        path=plugin_map['path'],
        core_or_contrib="contrib" in plugin_map['from manifest'] and "contrib" or "core",
        other="asdf",
    )
    pass


def write_documentation_for(plugin_info_map):
    # start with the manifest list
    md_out = io.StringIO()

    manifest_list = "\n".join(
        "- `{}`".format(mp) for mp in plugin_info_map['manifests']
    )

    display_map = {}

    for pt in otio.plugins.manifest.OTIO_PLUGIN_TYPES:
        pt_lines = []

        for plug in plugin_info_map[pt].values():
            if "ERROR" in plug or not plug:
                continue
            try:
                plug_lines = _format_plugin(plug)
            except:
                __import__('ipdb').set_trace()
            pt_lines.append(plug_lines)

        display_map[pt] = "\n".join((str(l) for l in pt_lines))

    md_out.write(
        DOCUMENT_HEADER.format(
            manifests=manifest_list,
            adapters=display_map['adapters'],
            media_linkers=display_map['media_linkers'],
            schemadefs=display_map['schemadefs'],
            hook_scripts=display_map['hook_scripts'],
            hooks=display_map['hooks'],
        )
    )

    return md_out.getvalue()


def main():
    """  main entry point  """

    args = _parsed_args()

    plugin_info_map = otio.plugins.plugin_info_map()

    docs = write_documentation_for(plugin_info_map)

    # print it out somewhere
    if args.dryrun:
        print(docs)
        return

    output = args.output
    if not output:
        output = tempfile.NamedTemporaryFile(
            'w',
            suffix="otio_serialized_schema.md",
            delete=False
        ).name

    with open(output, 'w') as fo:
        fo.write(docs)

    print("wrote documentation to {}.".format(output))


if __name__ == '__main__':
    main()
