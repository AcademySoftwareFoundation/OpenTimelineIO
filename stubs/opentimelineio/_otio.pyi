import opentimelineio._opentime
import typing
from typing import Callable, ClassVar, overload

class AnyDictionary:
    clear: ClassVar[Callable] = ...
    get: ClassVar[Callable] = ...
    items: ClassVar[Callable] = ...
    keys: ClassVar[Callable] = ...
    pop: ClassVar[Callable] = ...
    popitem: ClassVar[Callable] = ...
    setdefault: ClassVar[Callable] = ...
    update: ClassVar[Callable] = ...
    values: ClassVar[Callable] = ...
    __contains__: ClassVar[Callable] = ...
    __copy__: ClassVar[Callable] = ...
    __deepcopy__: ClassVar[Callable] = ...
    __eq__: ClassVar[Callable] = ...
    __setitem__: ClassVar[Callable] = ...
    def __init__(self) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __getitem__(self, key: str) -> object: ...
    def __internal_setitem__(self, key: str, item: PyAny) -> None: ...
    def __iter__(self) -> AnyDictionaryIterator: ...
    def __len__(self) -> int: ...

class AnyDictionaryIterator:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> AnyDictionaryIterator: ...
    def __next__(self) -> object: ...

class AnyVector:
    append: ClassVar[Callable] = ...
    clear: ClassVar[Callable] = ...
    count: ClassVar[Callable] = ...
    extend: ClassVar[Callable] = ...
    index: ClassVar[Callable] = ...
    insert: ClassVar[Callable] = ...
    pop: ClassVar[Callable] = ...
    remove: ClassVar[Callable] = ...
    reverse: ClassVar[Callable] = ...
    __add__: ClassVar[Callable] = ...
    __contains__: ClassVar[Callable] = ...
    __copy__: ClassVar[Callable] = ...
    __deepcopy__: ClassVar[Callable] = ...
    __delitem__: ClassVar[Callable] = ...
    __getitem__: ClassVar[Callable] = ...
    __iadd__: ClassVar[Callable] = ...
    __radd__: ClassVar[Callable] = ...
    __reversed__: ClassVar[Callable] = ...
    __setitem__: ClassVar[Callable] = ...
    def __init__(self) -> None: ...
    def __internal_delitem__(self, index: int) -> None: ...
    def __internal_getitem__(self, index: int) -> object: ...
    def __internal_setitem__(self, index: int, item: PyAny) -> None: ...
    def __iter__(self) -> AnyVectorIterator: ...
    def __len__(self) -> int: ...

class AnyVectorIterator:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> AnyVectorIterator: ...
    def __next__(self) -> object: ...

class Box2d:
    max: V2d
    min: V2d
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: V2d) -> None: ...
    @overload
    def __init__(self, arg0: V2d, arg1: V2d) -> None: ...
    def center(self) -> V2d: ...
    @overload
    def extendBy(self, arg0: V2d) -> None: ...
    @overload
    def extendBy(self, arg0: Box2d) -> None: ...
    @overload
    def intersects(self, arg0: V2d) -> bool: ...
    @overload
    def intersects(self, arg0: Box2d) -> bool: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __ne__(self, arg0: object) -> bool: ...

class CannotComputeAvailableRangeError(OTIOError): ...

class Clip(Item):
    DEFAULT_MEDIA_KEY: ClassVar[str] = ...  # read-only
    find_clips: ClassVar[Callable] = ...
    active_media_reference_key: str
    media_reference: MediaReference
    def __init__(self, name: str = ..., media_reference: MediaReference = ..., source_range: opentimelineio._opentime.TimeRange | None = ..., metadata: object = ..., effects: list[Effect] | None = ..., markers: list[Marker] | None = ..., active_media_reference: str = ...) -> None: ...
    def media_references(self) -> dict[str, MediaReference]: ...
    def set_media_references(self, arg0: dict[str, MediaReference], arg1: str) -> None: ...

class Composable(SerializableObjectWithMetadata):
    def __init__(self, name: str = ..., metadata: object = ...) -> None: ...
    def overlapping(self) -> bool: ...
    def parent(self) -> Composition: ...
    def visible(self) -> bool: ...

class Composition(Item):
    append: ClassVar[Callable] = ...
    clear: ClassVar[Callable] = ...
    count: ClassVar[Callable] = ...
    extend: ClassVar[Callable] = ...
    index: ClassVar[Callable] = ...
    insert: ClassVar[Callable] = ...
    pop: ClassVar[Callable] = ...
    remove: ClassVar[Callable] = ...
    reverse: ClassVar[Callable] = ...
    __add__: ClassVar[Callable] = ...
    __delitem__: ClassVar[Callable] = ...
    __getitem__: ClassVar[Callable] = ...
    __iadd__: ClassVar[Callable] = ...
    __radd__: ClassVar[Callable] = ...
    __reversed__: ClassVar[Callable] = ...
    __setitem__: ClassVar[Callable] = ...
    def __init__(self, name: str = ..., children: list[Composable] | None = ..., source_range: opentimelineio._opentime.TimeRange | None = ..., metadata: object = ...) -> None: ...
    def child_at_time(self, search_time: opentimelineio._opentime.RationalTime, shallow_search: bool = ...) -> Composable: ...
    def children_in_range(self, search_range: opentimelineio._opentime.TimeRange) -> list[SerializableObject]: ...
    def find_children(self, descended_from_type: object = ..., search_range: opentimelineio._opentime.TimeRange | None = ..., shallow_search: bool = ...) -> list[SerializableObject]: ...
    def handles_of_child(self, child: Composable) -> tuple: ...
    def has_clips(self) -> bool: ...
    def is_parent_of(self, other: Composable) -> bool: ...
    def range_of_all_children(self) -> dict: ...
    def range_of_child(self, child: Composable, reference_space: Composable = ...) -> opentimelineio._opentime.TimeRange: ...
    def range_of_child_at_index(self, index: int) -> opentimelineio._opentime.TimeRange: ...
    def trim_child_range(self, child_range: opentimelineio._opentime.TimeRange) -> opentimelineio._opentime.TimeRange | None: ...
    def trimmed_child_range(self, child_range: opentimelineio._opentime.TimeRange) -> opentimelineio._opentime.TimeRange | None: ...
    def trimmed_range_of_child(self, child: Composable, reference_space: Composable = ...) -> opentimelineio._opentime.TimeRange | None: ...
    def trimmed_range_of_child_at_index(self, index: int) -> opentimelineio._opentime.TimeRange: ...
    def __contains__(self, composable: Composable) -> bool: ...
    def __internal_delitem__(self, index: int) -> None: ...
    def __internal_getitem__(self, index: int) -> Composable: ...
    def __internal_setitem__(self, index: int, item: Composable) -> None: ...
    def __iter__(self) -> CompositionIterator: ...
    def __len__(self) -> int: ...
    @property
    def composition_kind(self) -> str: ...

class CompositionIterator:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> CompositionIterator: ...
    def __next__(self) -> Composable: ...

class Effect(SerializableObjectWithMetadata):
    effect_name: str
    enabled: bool
    def __init__(self, name: str = ..., effect_name: str = ..., metadata: object = ..., enabled: bool = ...) -> None: ...

class EffectVector:
    append: ClassVar[Callable] = ...
    clear: ClassVar[Callable] = ...
    count: ClassVar[Callable] = ...
    extend: ClassVar[Callable] = ...
    index: ClassVar[Callable] = ...
    insert: ClassVar[Callable] = ...
    pop: ClassVar[Callable] = ...
    remove: ClassVar[Callable] = ...
    reverse: ClassVar[Callable] = ...
    __add__: ClassVar[Callable] = ...
    __contains__: ClassVar[Callable] = ...
    __copy__: ClassVar[Callable] = ...
    __deepcopy__: ClassVar[Callable] = ...
    __delitem__: ClassVar[Callable] = ...
    __getitem__: ClassVar[Callable] = ...
    __iadd__: ClassVar[Callable] = ...
    __radd__: ClassVar[Callable] = ...
    __reversed__: ClassVar[Callable] = ...
    __setitem__: ClassVar[Callable] = ...
    def __init__(self) -> None: ...
    def __internal_delitem__(self, index: int) -> None: ...
    def __internal_getitem__(self, *args, **kwargs): ...
    def __internal_setitem__(self, index: int, item) -> None: ...
    def __iter__(self) -> EffectVectorIterator: ...
    def __len__(self) -> int: ...

class EffectVectorIterator:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> EffectVectorIterator: ...
    def __next__(self): ...

class ExternalReference(MediaReference):
    target_url: str
    def __init__(self, target_url: str = ..., available_range: opentimelineio._opentime.TimeRange | None = ..., metadata: object = ..., available_image_bounds: Box2d | None = ...) -> None: ...

class FreezeFrame(LinearTimeWarp):
    def __init__(self, name: str = ..., metadata: object = ...) -> None: ...

class Gap(Item):
    @overload
    def __init__(self, name: str = ..., source_range: opentimelineio._opentime.TimeRange = ..., effects: list[Effect] | None = ..., markers: list[Marker] | None = ..., metadata: object = ...) -> None: ...
    @overload
    def __init__(self, name: str = ..., duration: opentimelineio._opentime.RationalTime = ..., effects: list[Effect] | None = ..., markers: list[Marker] | None = ..., metadata: object = ...) -> None: ...

class GeneratorReference(MediaReference):
    generator_kind: str
    def __init__(self, name: str = ..., generator_kind: str = ..., available_range: opentimelineio._opentime.TimeRange | None = ..., parameters: object = ..., metadata: object = ..., available_image_bounds: Box2d | None = ...) -> None: ...
    @property
    def parameters(self) -> AnyDictionary: ...

class ImageSequenceReference(MediaReference):
    class MissingFramePolicy:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        black: ClassVar[ImageSequenceReference.MissingFramePolicy] = ...
        error: ClassVar[ImageSequenceReference.MissingFramePolicy] = ...
        hold: ClassVar[ImageSequenceReference.MissingFramePolicy] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    abstract_target_url: ClassVar[Callable] = ...
    frame_range_for_time_range: ClassVar[Callable] = ...
    frame_step: int
    frame_zero_padding: int
    missing_frame_policy: ImageSequenceReference.MissingFramePolicy
    name_prefix: str
    name_suffix: str
    rate: float
    start_frame: int
    target_url_base: str
    def __init__(self, target_url_base: str = ..., name_prefix: str = ..., name_suffix: str = ..., start_frame: int = ..., frame_step: int = ..., rate: float = ..., frame_zero_padding: int = ..., missing_frame_policy: ImageSequenceReference.MissingFramePolicy = ..., available_range: opentimelineio._opentime.TimeRange | None = ..., metadata: object = ..., available_image_bounds: Box2d | None = ...) -> None: ...
    def end_frame(self) -> int: ...
    def frame_for_time(self, time: opentimelineio._opentime.RationalTime) -> int: ...
    def number_of_images_in_sequence(self) -> int: ...
    def presentation_time_for_image_number(self, image_number: int) -> opentimelineio._opentime.RationalTime: ...
    def target_url_for_image_number(self, image_number: int) -> str: ...

class Item(Composable):
    enabled: bool
    source_range: opentimelineio._opentime.TimeRange | None
    def __init__(self, name: str = ..., source_range: opentimelineio._opentime.TimeRange | None = ..., effects: list[Effect] | None = ..., markers: list[Marker] | None = ..., enabled: bool = ..., metadata: object = ...) -> None: ...
    def available_range(self) -> opentimelineio._opentime.TimeRange: ...
    def duration(self) -> opentimelineio._opentime.RationalTime: ...
    def range_in_parent(self) -> opentimelineio._opentime.TimeRange: ...
    def transformed_time(self, time: opentimelineio._opentime.RationalTime, to_item: Item) -> opentimelineio._opentime.RationalTime: ...
    def transformed_time_range(self, time_range: opentimelineio._opentime.TimeRange, to_item: Item) -> opentimelineio._opentime.TimeRange: ...
    def trimmed_range(self) -> opentimelineio._opentime.TimeRange: ...
    def trimmed_range_in_parent(self) -> opentimelineio._opentime.TimeRange | None: ...
    def visible_range(self) -> opentimelineio._opentime.TimeRange: ...
    @property
    def available_image_bounds(self) -> Box2d | None: ...
    @property
    def effects(self) -> EffectVector: ...
    @property
    def markers(self) -> MarkerVector: ...

class LinearTimeWarp(TimeEffect):
    time_scalar: float
    def __init__(self, name: str = ..., time_scalar: float = ..., metadata: object = ...) -> None: ...

class Marker(SerializableObjectWithMetadata):
    class Color:
        BLACK: ClassVar[str] = ...  # read-only
        BLUE: ClassVar[str] = ...  # read-only
        CYAN: ClassVar[str] = ...  # read-only
        GREEN: ClassVar[str] = ...  # read-only
        MAGENTA: ClassVar[str] = ...  # read-only
        ORANGE: ClassVar[str] = ...  # read-only
        PINK: ClassVar[str] = ...  # read-only
        PURPLE: ClassVar[str] = ...  # read-only
        RED: ClassVar[str] = ...  # read-only
        WHITE: ClassVar[str] = ...  # read-only
        YELLOW: ClassVar[str] = ...  # read-only
        def __init__(self, *args, **kwargs) -> None: ...
    color: str
    comment: str
    marked_range: opentimelineio._opentime.TimeRange
    def __init__(self, name: str = ..., marked_range: opentimelineio._opentime.TimeRange = ..., color: str = ..., metadata: object = ..., comment: str = ...) -> None: ...

class MarkerVector:
    append: ClassVar[Callable] = ...
    clear: ClassVar[Callable] = ...
    count: ClassVar[Callable] = ...
    extend: ClassVar[Callable] = ...
    index: ClassVar[Callable] = ...
    insert: ClassVar[Callable] = ...
    pop: ClassVar[Callable] = ...
    remove: ClassVar[Callable] = ...
    reverse: ClassVar[Callable] = ...
    __add__: ClassVar[Callable] = ...
    __contains__: ClassVar[Callable] = ...
    __copy__: ClassVar[Callable] = ...
    __deepcopy__: ClassVar[Callable] = ...
    __delitem__: ClassVar[Callable] = ...
    __getitem__: ClassVar[Callable] = ...
    __iadd__: ClassVar[Callable] = ...
    __radd__: ClassVar[Callable] = ...
    __reversed__: ClassVar[Callable] = ...
    __setitem__: ClassVar[Callable] = ...
    def __init__(self) -> None: ...
    def __internal_delitem__(self, index: int) -> None: ...
    def __internal_getitem__(self, *args, **kwargs): ...
    def __internal_setitem__(self, index: int, item) -> None: ...
    def __iter__(self) -> MarkerVectorIterator: ...
    def __len__(self) -> int: ...

class MarkerVectorIterator:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> MarkerVectorIterator: ...
    def __next__(self): ...

class MediaReference(SerializableObjectWithMetadata):
    available_image_bounds: Box2d | None
    available_range: opentimelineio._opentime.TimeRange | None
    def __init__(self, name: str = ..., available_range: opentimelineio._opentime.TimeRange | None = ..., metadata: object = ..., available_image_bounds: Box2d | None = ...) -> None: ...
    @property
    def is_missing_reference(self) -> bool: ...

class MissingReference(MediaReference):
    def __init__(self, name: str = ..., available_range: opentimelineio._opentime.TimeRange | None = ..., metadata: object = ..., available_image_bounds: Box2d | None = ...) -> None: ...

class NotAChildError(OTIOError): ...

class OTIOError(Exception): ...

class PyAny:
    @overload
    def __init__(self, arg0: bool) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    @overload
    def __init__(self, arg0: float) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @overload
    def __init__(self, arg0: None) -> None: ...
    @overload
    def __init__(self, arg0: SerializableObject) -> None: ...
    @overload
    def __init__(self, arg0: opentimelineio._opentime.RationalTime) -> None: ...
    @overload
    def __init__(self, arg0: opentimelineio._opentime.TimeRange) -> None: ...
    @overload
    def __init__(self, arg0: opentimelineio._opentime.TimeTransform) -> None: ...
    @overload
    def __init__(self, arg0: V2d) -> None: ...
    @overload
    def __init__(self, arg0: Box2d) -> None: ...
    @overload
    def __init__(self, arg0: AnyVector) -> None: ...
    @overload
    def __init__(self, arg0: AnyDictionary) -> None: ...

class SerializableCollection(SerializableObjectWithMetadata):
    append: ClassVar[Callable] = ...
    clear: ClassVar[Callable] = ...
    count: ClassVar[Callable] = ...
    extend: ClassVar[Callable] = ...
    index: ClassVar[Callable] = ...
    insert: ClassVar[Callable] = ...
    pop: ClassVar[Callable] = ...
    remove: ClassVar[Callable] = ...
    reverse: ClassVar[Callable] = ...
    __add__: ClassVar[Callable] = ...
    __contains__: ClassVar[Callable] = ...
    __delitem__: ClassVar[Callable] = ...
    __getitem__: ClassVar[Callable] = ...
    __iadd__: ClassVar[Callable] = ...
    __radd__: ClassVar[Callable] = ...
    __reversed__: ClassVar[Callable] = ...
    __setitem__: ClassVar[Callable] = ...
    def __init__(self, name: str = ..., children: list[SerializableObject] | None = ..., metadata: object = ...) -> None: ...
    def find_children(self, descended_from_type: object = ..., search_range: opentimelineio._opentime.TimeRange | None = ..., shallow_search: bool = ...) -> list[SerializableObject]: ...
    def find_clips(self, search_range: opentimelineio._opentime.TimeRange | None = ..., shallow_search: bool = ...) -> list[SerializableObject]: ...
    def __internal_delitem__(self, index: int) -> None: ...
    def __internal_getitem__(self, index: int) -> SerializableObject: ...
    def __internal_setitem__(self, index: int, item: SerializableObject) -> None: ...
    def __iter__(self) -> SerializableCollectionIterator: ...
    def __len__(self) -> int: ...

class SerializableCollectionIterator:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> SerializableCollectionIterator: ...
    def __next__(self) -> SerializableObject: ...

class SerializableObject:
    deepcopy: ClassVar[Callable] = ...
    __copy__: ClassVar[Callable] = ...
    __deepcopy__: ClassVar[Callable] = ...
    __setattr__: ClassVar[Callable] = ...
    def __init__(self) -> None: ...
    def clone(self) -> SerializableObject: ...
    @staticmethod
    def from_json_file(file_name: str) -> SerializableObject: ...
    @staticmethod
    def from_json_string(input: str) -> SerializableObject: ...
    def is_equivalent_to(self, other: SerializableObject) -> bool: ...
    def schema_name(self) -> str: ...
    def schema_version(self) -> int: ...
    def to_json_file(self, file_name: str, indent: int = ...) -> bool: ...
    def to_json_string(self, indent: int = ...) -> str: ...
    @property
    def is_unknown_schema(self) -> bool: ...

class SerializableObjectWithMetadata(SerializableObject):
    name: object
    def __init__(self, name: str = ..., metadata: object = ...) -> None: ...
    @property
    def metadata(self) -> AnyDictionary: ...

class Stack(Composition):
    def __init__(self, name: str = ..., children: list[Composable] | None = ..., source_range: opentimelineio._opentime.TimeRange | None = ..., markers: list[Marker] | None = ..., effects: list[Effect] | None = ..., metadata: object = ...) -> None: ...
    def find_clips(self, search_range: opentimelineio._opentime.TimeRange | None = ..., shallow_search: bool = ...) -> list[SerializableObject]: ...

class TestObject(SerializableObjectWithMetadata):
    def __init__(self, name: str) -> None: ...
    def lookup(self, key: str) -> SerializableObject: ...

class TimeEffect(Effect):
    def __init__(self, name: str = ..., effect_name: str = ..., metadata: object = ...) -> None: ...

class Timeline(SerializableObjectWithMetadata):
    global_start_time: opentimelineio._opentime.RationalTime | None
    tracks: Stack
    def __init__(self, name: str = ..., tracks: list[Composable] | None = ..., global_start_time: opentimelineio._opentime.RationalTime | None = ..., metadata: object = ...) -> None: ...
    def audio_tracks(self) -> list[Track]: ...
    def duration(self) -> opentimelineio._opentime.RationalTime: ...
    def find_children(self, descended_from_type: object = ..., search_range: opentimelineio._opentime.TimeRange | None = ..., shallow_search: bool = ...) -> list[SerializableObject]: ...
    def find_clips(self, search_range: opentimelineio._opentime.TimeRange | None = ..., shallow_search: bool = ...) -> list[SerializableObject]: ...
    def range_of_child(self, arg0: Composable) -> opentimelineio._opentime.TimeRange: ...
    def video_tracks(self) -> list[Track]: ...

class Track(Composition):
    class Kind:
        Audio: ClassVar[str] = ...  # read-only
        Video: ClassVar[str] = ...  # read-only
        def __init__(self, *args, **kwargs) -> None: ...

    class NeighborGapPolicy:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        around_transitions: ClassVar[Track.NeighborGapPolicy] = ...
        never: ClassVar[Track.NeighborGapPolicy] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kind: str
    def __init__(self, name: str = ..., children: list[Composable] | None = ..., source_range: opentimelineio._opentime.TimeRange | None = ..., kind: str = ..., metadata: object = ...) -> None: ...
    def find_clips(self, search_range: opentimelineio._opentime.TimeRange | None = ..., shallow_search: bool = ...) -> list[SerializableObject]: ...
    def neighbors_of(self, item: Composable, policy: Track.NeighborGapPolicy = ...) -> tuple: ...

class Transition(Composable):
    class Type:
        Custom: ClassVar[str] = ...  # read-only
        SMPTE_Dissolve: ClassVar[str] = ...  # read-only
        def __init__(self, *args, **kwargs) -> None: ...
    in_offset: opentimelineio._opentime.RationalTime
    out_offset: opentimelineio._opentime.RationalTime
    transition_type: str
    def __init__(self, name: str = ..., transition_type: str = ..., in_offset: opentimelineio._opentime.RationalTime = ..., out_offset: opentimelineio._opentime.RationalTime = ..., metadata: object = ...) -> None: ...
    def duration(self) -> opentimelineio._opentime.RationalTime: ...
    def range_in_parent(self) -> opentimelineio._opentime.TimeRange | None: ...
    def trimmed_range_in_parent(self) -> opentimelineio._opentime.TimeRange | None: ...

class UnknownSchema(SerializableObject):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def original_schema_name(self) -> str: ...
    @property
    def original_schema_version(self) -> int: ...

class UnsupportedSchemaError(OTIOError): ...

class V2d:
    x: float
    y: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float) -> None: ...
    @overload
    def __init__(self, arg0: float, arg1: float) -> None: ...
    @staticmethod
    def baseTypeEpsilon() -> float: ...
    @staticmethod
    def baseTypeLowest() -> float: ...
    @staticmethod
    def baseTypeMax() -> float: ...
    @staticmethod
    def baseTypeSmallest() -> float: ...
    def cross(self, arg0: V2d) -> float: ...
    @staticmethod
    def dimensions() -> int: ...
    def dot(self, arg0: V2d) -> float: ...
    def equalWithAbsError(self, arg0: V2d, arg1: float) -> bool: ...
    def equalWithRelError(self, arg0: V2d, arg1: float) -> bool: ...
    def length(self) -> float: ...
    def length2(self) -> float: ...
    def normalize(self) -> V2d: ...
    def normalizeExc(self) -> V2d: ...
    def normalizeNonNull(self) -> V2d: ...
    def normalized(self) -> V2d: ...
    def normalizedExc(self) -> V2d: ...
    def normalizedNonNull(self) -> V2d: ...
    def __add__(self, arg0: V2d) -> V2d: ...
    def __eq__(self, arg0: object) -> bool: ...
    def __getitem__(self, arg0: int) -> float: ...
    def __iter__(self) -> typing.Iterator[float]: ...
    def __iadd__(self, arg0: V2d) -> V2d: ...
    def __idiv__(self, arg0: V2d) -> V2d: ...
    def __imul__(self, arg0: V2d) -> V2d: ...
    def __isub__(self, arg0: V2d) -> V2d: ...
    def __mod__(self, arg0: object) -> float: ...
    def __mul__(self, arg0: V2d) -> V2d: ...
    def __ne__(self, arg0: object) -> bool: ...
    def __sub__(self, arg0: V2d) -> V2d: ...
    def __truediv__(self, arg0: V2d) -> V2d: ...
    def __xor__(self, arg0: object) -> float: ...

def deserialize_json_from_file(filename: str) -> object: ...
def deserialize_json_from_string(input: str) -> object: ...
@overload
def flatten_stack(in_stack: Stack) -> Track: ...
@overload
def flatten_stack(tracks: list[Track]) -> Track: ...
def install_external_keepalive_monitor(so: SerializableObject, apply_now: bool) -> None: ...
def instance_from_schema(schema_name: str, schema_version: int, data: object) -> SerializableObject: ...
def register_downgrade_function(schema_name: str, version_to_downgrade_from: int, downgrade_function: Callable[[AnyDictionary], None]) -> bool: ...
def register_serializable_object_type(class_object: object, schema_name: str, schema_version: int) -> None: ...
def register_upgrade_function(schema_name: str, version_to_upgrade_to: int, upgrade_function: Callable[[AnyDictionary], None]) -> bool: ...
def release_to_schema_version_map() -> dict[str, dict[str, int]]: ...
def set_type_record(serializable_obejct: SerializableObject, schema_name: str) -> None: ...
def type_version_map() -> dict[str, int]: ...
